<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [一些设计规范摘录](#%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [滥用全局变量和全局方法](#%E6%BB%A5%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95)
  - [接口](#%E6%8E%A5%E5%8F%A3)
  - [是否推荐使用继承](#%E6%98%AF%E5%90%A6%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF)
  - [贫血模型的MVC架构](#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84mvc%E6%9E%B6%E6%9E%84)
  - [基于充血模型的DDD开发模式](#%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84ddd%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F)
  - [单一职责原则（SRP）](#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
    - [理解单一职责原则（SRP）](#%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
    - [如何判断类的职责是否足够单一](#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E5%8D%95%E4%B8%80)
    - [类的职责是否设计得越单一越好](#%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%AE%BE%E8%AE%A1%E5%BE%97%E8%B6%8A%E5%8D%95%E4%B8%80%E8%B6%8A%E5%A5%BD)
  - [开闭原则](#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99)
    - [如何理解“对扩展开放、修改关闭”](#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD)
    - [如何做到“对扩展开放、修改关闭”？](#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD)
  - [里式替换原则（LSP）](#%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp)
    - [违背LSP的场景](#%E8%BF%9D%E8%83%8Clsp%E7%9A%84%E5%9C%BA%E6%99%AF)
  - [接口隔离原则](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99)
    - [把“接口”理解为一组API接口集合](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BA%E4%B8%80%E7%BB%84api%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88)
    - [把“接口”理解为单个API接口或函数](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BA%E5%8D%95%E4%B8%AAapi%E6%8E%A5%E5%8F%A3%E6%88%96%E5%87%BD%E6%95%B0)
    - [把“接口”理解为OOP中的接口概念](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BAoop%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5)
    - [接口隔离原则与单一职责原则的区别](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E4%B8%8E%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [依赖反转原则](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99)
    - [控制反转（IOC）](#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc)
    - [依赖注入（DI）](#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di)
    - [依赖反转原则（DIP）](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99dip)
  - [如何理解“KISS原则”](#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3kiss%E5%8E%9F%E5%88%99)
    - [如何写出满足KISS原则的代码？](#%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%BB%A1%E8%B6%B3kiss%E5%8E%9F%E5%88%99%E7%9A%84%E4%BB%A3%E7%A0%81)
  - [YAGNI原则](#yagni%E5%8E%9F%E5%88%99)
  - [DRY原则（Don’t Repeat Yourself）](#dry%E5%8E%9F%E5%88%99dont-repeat-yourself)
    - [辩证思考和灵活应用](#%E8%BE%A9%E8%AF%81%E6%80%9D%E8%80%83%E5%92%8C%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8)
  - [什么是高内聚、松耦合](#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%86%85%E8%81%9A%E6%9D%BE%E8%80%A6%E5%90%88)
    - [什么是高内聚](#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%86%85%E8%81%9A)
    - [什么是松耦合](#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%BE%E8%80%A6%E5%90%88)
  - [迪米特法则](#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99)
  - [针对系统业务做需求分析](#%E9%92%88%E5%AF%B9%E7%B3%BB%E7%BB%9F%E4%B8%9A%E5%8A%A1%E5%81%9A%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90)
    - [模块和模块之间的交互](#%E6%A8%A1%E5%9D%97%E5%92%8C%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92)
  - [重构](#%E9%87%8D%E6%9E%84)
    - [为什么需要重构](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%87%8D%E6%9E%84)
    - [什么时候重构](#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84)
    - [如何重构](#%E5%A6%82%E4%BD%95%E9%87%8D%E6%9E%84)
  - [单元测试](#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)
  - [代码解耦](#%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%80%A6)
    - [解耦的重要性](#%E8%A7%A3%E8%80%A6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7)
    - [如何判断代码是否需要解耦](#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%A7%A3%E8%80%A6)
    - [如何解耦](#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%80%A6)
  - [审查代码问题](#%E5%AE%A1%E6%9F%A5%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98)
    - [代码质量问题](#%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98)
    - [针对业务角度进行考虑](#%E9%92%88%E5%AF%B9%E4%B8%9A%E5%8A%A1%E8%A7%92%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%80%83%E8%99%91)
  - [接口的幂等性](#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7)
  - [灰度发布组件](#%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%BB%84%E4%BB%B6)
  - [Code Review](#code-review)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 一些设计规范摘录

### 前言

设计模式学习的一些笔记  

### 滥用全局变量和全局方法

**全局常量的使用**  

全局常量我们尽量不要统一放在同一个地方  

- 1、因为随着变量的增多，会影响代码的可维护性 

参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个文件，会造成这个文件很大，同时也增加了代码冲突的概率。  

- 会增加代码的编译时间  

每次修改这个文件，所有这个文件，所有依赖这个文件的代码就会编译，增加编译时间  

如何使用最优化  

我们可以把不同类型的群居变量放到把不同的文件中，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计Constants常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig类用到了Redis配置相关的常量，那我们就直接将这些常量定义在RedisConfig中，这样也提高了类设计的内聚性和代码的复用性。  

**Utils类**

Utils 能解决代码复用的问题，虽然只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。   

当然，我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，不要设计一个过于大而全的Utils类。  
   
### 接口

接口设计的原则：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。  

什么时候需要封装接口？  

- 1、如果某个功能只有一种实现那么我们就没必要定义接口了。  

- 2、越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。  

### 是否推荐使用继承

继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性  

我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，来替换继承。   

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。  

### 贫血模型的MVC架构

来看下什么是贫血模式  

MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。  

我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然不同的团队有不同的命名，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。  

```
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    return userVo;
  }
}

public class UserVo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}
``` 

其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。  

UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。  

### 基于充血模型的DDD开发模式  

什么是充血模式？  

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。  

基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。它跟基于贫血模型的传统开发模式的区别主要在Service层。  

在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。  

### 单一职责原则（SRP）

#### 理解单一职责原则（SRP）

单一职责原则的英文是Single Responsibility Principle，缩写为SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。  

原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念的理解  

一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。  

另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。  

接下我们从类的角度进行分析  

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。  

举个栗子  

比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。  

#### 如何判断类的职责是否足够单一

评级一个类是否单一，没有一个明确的标准可以量化的，实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。   

我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构  

下面的几个原则可以作为直观的判断类是否单一  

1、类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；  

2、类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；  

3、私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；  

4、比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；  

5、类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来  

一般一个类的代码行数最好不能超过200行，函数个数及属性个数都最好不要超过10个。  

#### 类的职责是否设计得越单一越好

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。  

### 开闭原则

扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。  

#### 如何理解“对扩展开放、修改关闭”

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。   

不过添加新功能不修改任何模板，类，方法，这个肯定是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。  

#### 如何做到“对扩展开放、修改关闭”？  

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。  

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）  

也就是我们首先要去学习下这23种设计模式   

### 里式替换原则（LSP）

什么是里式替换原则：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。  

从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。  

#### 违背LSP的场景

1、子类违背父类声明要实现的功能 

2、子类违背父类对输入、输出、异常的约定  

3、子类违背父类注释中所罗列的任何特殊说明  

父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。  

### 接口隔离原则

什么意思呢：Robert Martin在SOLID原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。  

关于接口的理解：  

- 一组API接口集合

- 单个API接口或函数

- OOP中的接口概念

#### 把“接口”理解为一组API接口集合

如果理解为一组 api 接口的话，在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。  

如果 API 接口集合中放置了我们用到的接口，那么我们可以认为不符合接口隔离原则。  

#### 把“接口”理解为单个API接口或函数

这里就不是单个API接口或函数统称为函数了。  

那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。  

#### 把“接口”理解为OOP中的接口概念

接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。  

#### 接口隔离原则与单一职责原则的区别

仔细想想和单一职责原则有点类似，不过还是有差别的。  

- 单一职责原则针对的是模块、类、接口的设计。  

- 接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。   

它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。  

### 依赖反转原则

在学习依赖反转原则之前我们先来了解几个概念 控制反转、依赖反转、依赖注入  

#### 控制反转（IOC）

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。  

#### 依赖注入（DI）

依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。  

我们用一句话表示就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。  

#### 依赖反转原则（DIP）

依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP。  

什么是依赖反转原则：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。  

所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。不过平时在业务代码的开发中，高层模块依赖底层模块是没有任何问题的。这里我们讲的这个原则主要是针对框架层面的开发设计和开发的。  
 
### 如何理解“KISS原则”

KISS原则是英语 Keep It Simple, Stupid 的首字母缩略字，是一种归纳过的经验原则。KISS 原则是指在设计当中应当注重简约的原则。总结工程专业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而不掺入非必要的复杂性，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，尽量回避免不必要的复杂性

代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。  

#### 如何写出满足KISS原则的代码？

- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。  

- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。  

- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。  

就是尽量做到把很难的东西做到简单化    

### YAGNI原则

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。  

比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。  

KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。  

### DRY原则（Don’t Repeat Yourself）

它的英文描述为：Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。  

代码的三种重复方式  

**1、实现逻辑重复**  

**2、功能语义重复**    

功能相同的函数，不要定义多个，如果后面我们修改了其中一个，但是另一个忘记修改，就会造成一下程序的bug，并且也不好排查。  

**3、代码执行重复** 

我们开发新代码的过程中，尽量复用已经存在的代码。代码的可复用，表示一段代码可复用的能力，我们编写代码的过程中，让代码尽量保持复用。   

“不重复”并不代表“可复用”     

“复用”和“可复用性”关注角度不同  

#### 辩证思考和灵活应用

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。  

### 什么是高内聚、松耦合

“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。  

“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。  

#### 什么是高内聚

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。  

#### 什么是松耦合

所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。  

<img src="/img/lod_1.jpeg"  alt="lod" align=center />

左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。  

左边的代码如果我们需要修改，因为是“高内聚、松耦合”的，一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。  

右边的代码是“低内聚、紧耦合”，一个类的修改可能影响到多处代码，我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。   

### 迪米特法则

来看下定义：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。  

### 针对系统业务做需求分析

技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。  

#### 模块和模块之间的交互

上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用  

### 重构

“重构不改变外部的可见行为”。我们可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。  

#### 为什么需要重构

1、及时的重构能够保持代码的质量，避免代码混乱然后两变引起质变  

2、好的代码，不是刚开始就能想好的，需要不断地改进迭代  

3、避免过度设计  

#### 什么时候重构

要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。  

#### 如何重构

大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。  

### 单元测试

单元测试还是挺重要的，提高代码质量，方面后面的维护，自己需要在这方面注意了  

在平时的开发中有时候，我们或发现我们的代码不好写单元测试。这很大的层面上是我们的代码写的不太好，也就是可测试性差，当然我们需要对我们的代码就行修改。  

代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，我们也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于我们设计出好的代码。  

对于一下代码中的外部依赖，比如数据库，mq，。。。,我们可以使用mock的方式解决，当然一些框架可能已将继承了mock的方法，不过我们也可以手动的写一些mock的数据。   

### 代码解耦

#### 解耦的重要性

代码负载在可读性，可维护性上不好。代码高内聚低耦合，意味着代码结构清晰，分层合理，依赖关系简单，模块与类之间的藕合小，代码的质量就不会太差。   

#### 如何判断代码是否需要解耦

最重要的思想就是看改动代码会不会牵一发而动全身  

还有就是画出类与类之前的依赖关系画出来，根据关系图的复杂度来判断是否需要解耦重构  

#### 如何解耦

封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。  


### 审查代码问题

当我们写一段代码的时候，在做审查的时候，可以从下面的几个点来进行代码质量的检查  

#### 代码质量问题  

- 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？

- 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD等）？

- 设计模式是否应用得当？是否有过度设计？

- 代码是否容易扩展？如果要添加新功能，是否容易实现？

- 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？

- 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？

- 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

#### 针对业务角度进行考虑

- 代码是否实现了预期的业务需求？

- 逻辑是否正确？是否处理了各种异常情况？

- 日志打印是否得当？是否方便debug排查问题？

- 接口是否易用？是否支持幂等、事务等？

- 代码是否存在并发问题？是否线程安全？

- 性能是否有优化空间，比如，SQL、算法是否可以优化？

- 是否有安全漏洞？比如输入输出校验是否全面？

### 接口的幂等性 

接口报错的处理方法  

第一种处理方式是，调用方访问公共服务平台接口超时时，返回清晰明确的提醒给用户，告知执行结果未知，让用户自己判断是否重试。  

第二种处理方式是，调用方调用其他接口，来查询超时操作的结果，明确超时操作对应的业务，是执行成功了还是失败了，然后再基于明确的结果做处理。  

第三种处理方式是，调用方在遇到接口超时之后，直接发起重试操作。接口要支持幂等性，同时调用方要加入重试的机制。  

什么是幂等性  

幂等的意思是，针对同一个接口，多次发起同一个业务请求，必须保证业务只执行一次。  

如果需要确定重试关系，我们的业务需要一个唯一标识，也叫做幂等号，如果两个接口请求，带有相同的幂等号，那我们就判断它们是重试关系，是同一个业务请求，不要重复执行。  

当业务代码出问题的时候，我们要考虑删除幂等号，是否删除如何考量呢？  

这时候我们需要区分一些业务报错和系统报错  

比如，A用户发送消息给B用户，但是查询B用户不存在，抛出UserNotExisting异常，我们把这种业务上不符合预期叫做业务异常。因为数据库挂掉了，业务代码访问数据库时，就会报告数据库异常，我们把这种非业务层面的、系统级的异常，叫做系统异常。  

业务报错可以不允许重试，因为重试的结果还是一样的，系统报错是需要重试，也就是我们需要删除记录的幂等号。   

当然扩展性更友好的话，可以提供一个参数，让实际的业务调用者来决定幂等号是否删除。    

对于异常情况，比如系统宕机了，这时候幂等号是否记录上了就不能确定了，对于这种情况，可以让幂等号的记录通过分布式事务来解决，或加入到业务表中。不过，对于这种极少发生的异常，在工程中，我们能够做到，在出错时能及时发现问题、能够根据记录的信息人工修复就可以了。  

对于限流如果限流组件出现异常了，是可以放过这次请求的，因为限流是为了应为突发的情况的，偶尔一两个失效是可以接受的。  

对于幂等性就不同了，如果本不应该重新执行的业务逻辑，因为幂等功能的暂时失效，被重复执行了，就会导致业务出错。如果幂等性的组件出现异常的情况下，直接应该返回失败，拦截掉这个请求。毕竟接口请求失败（比如转钱没转成功），比业务执行出错（比如多转了钱），修复的成本要低很多。   

### 灰度发布组件

灰度发布可以分为三个不同层面的灰度：产品层面的灰度、系统层面的灰度和代码层面的灰度。我们今天重点讲解代码层面的灰度，通过编程来控制是否执行新的代码逻辑，以及灰度执行新的代码逻辑。  

这里我们讨论的灰度发布组件是代码层面上的灰度   

灰度发布组件存在的意义：  

主要解决代码质量问题，通过逐渐放量灰度执行，来降低重大代码改动带来的风险。在出现问题之后，在不需要修改代码、重新部署、重启系统的情况下，实现快速地回滚。相对于系统层面的灰度，它可以做得更加细粒度，更加灵活、简单、好维护，但也存在着代码侵入的问题，灰度代码跟业务代码耦合在一起。  

如何实现：  

这种实现的额方式还是很多的，比如可以加一些业务的开关，出问题直接关闭，业务还是走老的逻辑  

还可以分批发布，根据业务的某一个属性，编写对应的发布规则，满足规则走新业务，否则走老逻辑   

### Code Review  

关于 Code Review 也是会吹毛求疵的对各种细节进行讨论，明亮，空格，注释的细节。。。当然看起来很烦，但是是需要我们注意的点。   

