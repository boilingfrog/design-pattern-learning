<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [一些设计规范摘录](#%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [滥用全局变量和全局方法](#%E6%BB%A5%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95)
  - [接口](#%E6%8E%A5%E5%8F%A3)
  - [是否推荐使用继承](#%E6%98%AF%E5%90%A6%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF)
  - [贫血模型的MVC架构](#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84mvc%E6%9E%B6%E6%9E%84)
  - [基于充血模型的DDD开发模式](#%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84ddd%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F)
  - [单一职责原则（SRP）](#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
    - [理解单一职责原则（SRP）](#%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
    - [如何判断类的职责是否足够单一](#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E5%8D%95%E4%B8%80)
    - [类的职责是否设计得越单一越好](#%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%AE%BE%E8%AE%A1%E5%BE%97%E8%B6%8A%E5%8D%95%E4%B8%80%E8%B6%8A%E5%A5%BD)
  - [开闭原则](#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99)
    - [如何理解“对扩展开放、修改关闭”](#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD)
    - [如何做到“对扩展开放、修改关闭”？](#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD)
  - [里式替换原则（LSP）](#%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp)
    - [违背LSP的场景](#%E8%BF%9D%E8%83%8Clsp%E7%9A%84%E5%9C%BA%E6%99%AF)
  - [接口隔离原则](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99)
    - [把“接口”理解为一组API接口集合](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BA%E4%B8%80%E7%BB%84api%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88)
    - [把“接口”理解为单个API接口或函数](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BA%E5%8D%95%E4%B8%AAapi%E6%8E%A5%E5%8F%A3%E6%88%96%E5%87%BD%E6%95%B0)
    - [把“接口”理解为OOP中的接口概念](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BAoop%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5)
    - [接口隔离原则与单一职责原则的区别](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E4%B8%8E%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [依赖反转原则](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99)
    - [控制反转（IOC）](#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc)
    - [依赖注入（DI）](#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di)
    - [依赖反转原则（DIP）](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99dip)
  - [如何理解“KISS原则”](#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3kiss%E5%8E%9F%E5%88%99)
    - [如何写出满足KISS原则的代码？](#%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%BB%A1%E8%B6%B3kiss%E5%8E%9F%E5%88%99%E7%9A%84%E4%BB%A3%E7%A0%81)
  - [YAGNI原则](#yagni%E5%8E%9F%E5%88%99)
  - [DRY原则（Don’t Repeat Yourself）](#dry%E5%8E%9F%E5%88%99dont-repeat-yourself)
    - [辩证思考和灵活应用](#%E8%BE%A9%E8%AF%81%E6%80%9D%E8%80%83%E5%92%8C%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8)
  - [什么是高内聚、松耦合](#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%86%85%E8%81%9A%E6%9D%BE%E8%80%A6%E5%90%88)
    - [什么是高内聚](#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%86%85%E8%81%9A)
    - [什么是松耦合](#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%BE%E8%80%A6%E5%90%88)
  - [迪米特法则](#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99)
  - [针对系统业务做需求分析](#%E9%92%88%E5%AF%B9%E7%B3%BB%E7%BB%9F%E4%B8%9A%E5%8A%A1%E5%81%9A%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90)
    - [模块和模块之间的交互](#%E6%A8%A1%E5%9D%97%E5%92%8C%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92)
  - [重构](#%E9%87%8D%E6%9E%84)
    - [为什么需要重构](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%87%8D%E6%9E%84)
    - [什么时候重构](#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84)
    - [如何重构](#%E5%A6%82%E4%BD%95%E9%87%8D%E6%9E%84)
  - [单元测试](#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)
  - [代码解耦](#%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%80%A6)
    - [解耦的重要性](#%E8%A7%A3%E8%80%A6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7)
    - [如何判断代码是否需要解耦](#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%A7%A3%E8%80%A6)
    - [如何解耦](#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%80%A6)
  - [代码规范](#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83)
    - [命名](#%E5%91%BD%E5%90%8D)
      - [1、命名的长度选择](#1%E5%91%BD%E5%90%8D%E7%9A%84%E9%95%BF%E5%BA%A6%E9%80%89%E6%8B%A9)
      - [2、利用上下文简化命名](#2%E5%88%A9%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%80%E5%8C%96%E5%91%BD%E5%90%8D)
      - [3.命名要可读、可搜索](#3%E5%91%BD%E5%90%8D%E8%A6%81%E5%8F%AF%E8%AF%BB%E5%8F%AF%E6%90%9C%E7%B4%A2)
      - [4.如何命名接口和抽象类？](#4%E5%A6%82%E4%BD%95%E5%91%BD%E5%90%8D%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB)
    - [注释](#%E6%B3%A8%E9%87%8A)
      - [1.注释到底该写什么？](#1%E6%B3%A8%E9%87%8A%E5%88%B0%E5%BA%95%E8%AF%A5%E5%86%99%E4%BB%80%E4%B9%88)
      - [2.注释是不是越多越好？](#2%E6%B3%A8%E9%87%8A%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD)
    - [代码风格](#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC)
      - [1.函数多大才合适？](#1%E5%87%BD%E6%95%B0%E5%A4%9A%E5%A4%A7%E6%89%8D%E5%90%88%E9%80%82)
      - [2.一行代码多长最合适？](#2%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%A4%9A%E9%95%BF%E6%9C%80%E5%90%88%E9%80%82)
      - [2.善用空行分割单元块](#2%E5%96%84%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%88%86%E5%89%B2%E5%8D%95%E5%85%83%E5%9D%97)
    - [编程技巧](#%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7)
      - [1.把代码分割成更小的单元块](#1%E6%8A%8A%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E6%88%90%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%8D%95%E5%85%83%E5%9D%97)
      - [2.避免函数参数过多](#2%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BF%87%E5%A4%9A)
      - [3.勿用函数参数来控制逻辑](#3%E5%8B%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%9D%A5%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91)
      - [4.函数设计要职责单一](#4%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E8%A6%81%E8%81%8C%E8%B4%A3%E5%8D%95%E4%B8%80)
      - [5.移除过深的嵌套层次](#5%E7%A7%BB%E9%99%A4%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B5%8C%E5%A5%97%E5%B1%82%E6%AC%A1)
      - [6.学会使用解释性变量](#6%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E6%80%A7%E5%8F%98%E9%87%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 一些设计规范摘录

### 前言

设计模式学习的一些笔记  

### 滥用全局变量和全局方法

**全局常量的使用**  

全局常量我们尽量不要统一放在同一个地方  

- 1、因为随着变量的增多，会影响代码的可维护性 

参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个文件，会造成这个文件很大，同时也增加了代码冲突的概率。  

- 会增加代码的编译时间  

每次修改这个文件，所有这个文件，所有依赖这个文件的代码就会编译，增加编译时间  

如何使用最优化  

我们可以把不同类型的群居变量放到把不同的文件中，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计Constants常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig类用到了Redis配置相关的常量，那我们就直接将这些常量定义在RedisConfig中，这样也提高了类设计的内聚性和代码的复用性。  

**Utils类**

Utils 能解决代码复用的问题，虽然只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。   

当然，我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，不要设计一个过于大而全的Utils类。  
   
### 接口

接口设计的原则：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。  

什么时候需要封装接口？  

- 1、如果某个功能只有一种实现那么我们就没必要定义接口了。  

- 2、越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。  

### 是否推荐使用继承

继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性  

我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，来替换继承。   

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。  

### 贫血模型的MVC架构

来看下什么是贫血模式  

MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。  

我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然不同的团队有不同的命名，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。  

```
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    return userVo;
  }
}

public class UserVo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}
``` 

其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。  

UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。  

### 基于充血模型的DDD开发模式  

什么是充血模式？  

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。  

基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。它跟基于贫血模型的传统开发模式的区别主要在Service层。  

在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。  

### 单一职责原则（SRP）

#### 理解单一职责原则（SRP）

单一职责原则的英文是Single Responsibility Principle，缩写为SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。  

原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念的理解  

一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。  

另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。  

接下我们从类的角度进行分析  

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。  

举个栗子  

比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。  

#### 如何判断类的职责是否足够单一

评级一个类是否单一，没有一个明确的标准可以量化的，实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。   

我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构  

下面的几个原则可以作为直观的判断类是否单一  

1、类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；  

2、类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；  

3、私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；  

4、比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；  

5、类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来  

一般一个类的代码行数最好不能超过200行，函数个数及属性个数都最好不要超过10个。  

#### 类的职责是否设计得越单一越好

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。  

### 开闭原则

扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。  

#### 如何理解“对扩展开放、修改关闭”

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。   

不过添加新功能不修改任何模板，类，方法，这个肯定是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。  

#### 如何做到“对扩展开放、修改关闭”？  

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。  

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）  

也就是我们首先要去学习下这23种设计模式   

### 里式替换原则（LSP）

什么是里式替换原则：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。  

从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。  

#### 违背LSP的场景

1、子类违背父类声明要实现的功能 

2、子类违背父类对输入、输出、异常的约定  

3、子类违背父类注释中所罗列的任何特殊说明  

父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。  

### 接口隔离原则

什么意思呢：Robert Martin在SOLID原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。  

关于接口的理解：  

- 一组API接口集合

- 单个API接口或函数

- OOP中的接口概念

#### 把“接口”理解为一组API接口集合

如果理解为一组 api 接口的话，在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。  

如果 API 接口集合中放置了我们用到的接口，那么我们可以认为不符合接口隔离原则。  

#### 把“接口”理解为单个API接口或函数

这里就不是单个API接口或函数统称为函数了。  

那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。  

#### 把“接口”理解为OOP中的接口概念

接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。  

#### 接口隔离原则与单一职责原则的区别

仔细想想和单一职责原则有点类似，不过还是有差别的。  

- 单一职责原则针对的是模块、类、接口的设计。  

- 接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。   

它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。  

### 依赖反转原则

在学习依赖反转原则之前我们先来了解几个概念 控制反转、依赖反转、依赖注入  

#### 控制反转（IOC）

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。  

#### 依赖注入（DI）

依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。  

我们用一句话表示就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。  

#### 依赖反转原则（DIP）

依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP。  

什么是依赖反转原则：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。  

所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。不过平时在业务代码的开发中，高层模块依赖底层模块是没有任何问题的。这里我们讲的这个原则主要是针对框架层面的开发设计和开发的。  
 
### 如何理解“KISS原则”

KISS原则是英语 Keep It Simple, Stupid 的首字母缩略字，是一种归纳过的经验原则。KISS 原则是指在设计当中应当注重简约的原则。总结工程专业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而不掺入非必要的复杂性，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，尽量回避免不必要的复杂性

代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。  

#### 如何写出满足KISS原则的代码？

- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。  

- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。  

- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。  

就是尽量做到把很难的东西做到简单化    

### YAGNI原则

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。  

比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。  

KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。  

### DRY原则（Don’t Repeat Yourself）

它的英文描述为：Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。  

代码的三种重复方式  

**1、实现逻辑重复**  

**2、功能语义重复**    

功能相同的函数，不要定义多个，如果后面我们修改了其中一个，但是另一个忘记修改，就会造成一下程序的bug，并且也不好排查。  

**3、代码执行重复** 

我们开发新代码的过程中，尽量复用已经存在的代码。代码的可复用，表示一段代码可复用的能力，我们编写代码的过程中，让代码尽量保持复用。   

“不重复”并不代表“可复用”     

“复用”和“可复用性”关注角度不同  

#### 辩证思考和灵活应用

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。  

### 什么是高内聚、松耦合

“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。  

“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。  

#### 什么是高内聚

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。  

#### 什么是松耦合

所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。  

<img src="/img/lod_1.jpeg"  alt="lod" align=center />

左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。  

左边的代码如果我们需要修改，因为是“高内聚、松耦合”的，一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。  

右边的代码是“低内聚、紧耦合”，一个类的修改可能影响到多处代码，我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。   

### 迪米特法则

来看下定义：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。  

### 针对系统业务做需求分析

技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。  

#### 模块和模块之间的交互

上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用  

### 重构

“重构不改变外部的可见行为”。我们可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。  

#### 为什么需要重构

1、及时的重构能够保持代码的质量，避免代码混乱然后两变引起质变  

2、好的代码，不是刚开始就能想好的，需要不断地改进迭代  

3、避免过度设计  

#### 什么时候重构

要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。  

#### 如何重构

大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。  

### 单元测试

单元测试还是挺重要的，提高代码质量，方面后面的维护，自己需要在这方面注意了  

在平时的开发中有时候，我们或发现我们的代码不好写单元测试。这很大的层面上是我们的代码写的不太好，也就是可测试性差，当然我们需要对我们的代码就行修改。  

代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，我们也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于我们设计出好的代码。  

对于一下代码中的外部依赖，比如数据库，mq，。。。,我们可以使用mock的方式解决，当然一些框架可能已将继承了mock的方法，不过我们也可以手动的写一些mock的数据。   

### 代码解耦

#### 解耦的重要性

代码负载在可读性，可维护性上不好。代码高内聚低耦合，意味着代码结构清晰，分层合理，依赖关系简单，模块与类之间的藕合小，代码的质量就不会太差。   

#### 如何判断代码是否需要解耦

最重要的思想就是看改动代码会不会牵一发而动全身  

还有就是画出类与类之前的依赖关系画出来，根据关系图的复杂度来判断是否需要解耦重构  

#### 如何解耦

封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。  

### 代码规范

#### 命名

选取一个合适的命名有时候确实是很难的，来看下有哪些可以帮我我们命名的技巧  

##### 1、命名的长度选择  

关于命名长度，在能够表达含义的额情况下，命名当然是越短越好。在大多数的情况下，短的命名不如长的命名更能表达含义，很多书籍是不推荐使用缩写的。 

在什么场景下合适使用短命名    

1、对于一些默认，大家都熟知的倒是可以使用缩写的命名，比如，sec 表示 second、str 表示 string、num 表示 number、doc 表示 document 等等   

2、对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量，相对应的对于作用于比较大的，更推荐使用长命名   

##### 2、利用上下文简化命名  

来看个栗子  

```go
type User struct {
	UserName      string
	UserAge       string
	UserAvatarUrl string
}
```

比如这个struct，我们已经知道这是一个 User 信息的 struct。里面用户的 name ,age，就没有必要加上user的前缀了   

修稿后的  

```go
type User struct {
	Name      string
	Age       string
	AvatarUrl string
}
```

当然这个在数据库的设计中也是同样有用   

##### 3.命名要可读、可搜索

“可读”，指的是不要用一些特别生僻、难发音的英文单词来命名。  

我们在IDE中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索。比如，键入某个对象“.get”，希望IDE返回这个对象的所有get开头的方法。再比如，通过在IDE搜索框中输入“Array”，搜索JDK中数组相关的类。所以，我们在命名的时候，最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦。  

##### 4.如何命名接口和抽象类？  

对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个Interface。比如IUserService，对应的实现类命名为UserService。另一种是不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。  

对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。  

#### 注释

我们接受一个项目的时候，经常会吐槽老项目注释不好，文档不全，那么如果注释都让我们去写，怎样的注释才是好的注释   

有时候我们会在书籍或一些博客中看到，如果好的命名是不需要注释的，也就是代码即注释，如果需要注释了，就是代码的命名不好了，需要在命名中下功夫。  

这种是有点极端了，命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。   

##### 1.注释到底该写什么？  

我们写数注释的目的是让代码更易懂，注释一般包括三个方面，做什么、为什么、怎么做。  

有些人认为，注释是要提供一些代码没有的额外信息，所以不要写“做什么、怎么做”，这两方面在代码中都可以体现出来，只需要写清楚“为什么”，表明代码的设计意图即可。   

不过写了注释可能有以下几个优点  

1、注释比代码承载的信息更多  

2、注释起到总结性作用、文档的作用  

3、一些总结性注释能让代码结构更清晰  

```
public boolean isValidPasword(String password) {
  // check if password is null or empty
  if (StringUtils.isBlank(password)) {
    return false;
  }

  // check if the length of password is between 4 and 64
  int length = password.length();
  if (length < 4 || length > 64) {
    return false;
  }
    
  // check if password contains only a~z,0~9,dot
  for (int i = 0; i < length; ++i) {
    char c = password.charAt(i);
    if (!((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.')) {
      return false;
    }
  }
  return true;
}
```

##### 2.注释是不是越多越好？

注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。  

#### 代码风格

##### 1.函数多大才合适？  

函数的代码太多和太少，都是不太好的  

太多了：  

一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面  

太少了：  

在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在n多类或者n多函数之间跳来跳去，阅读体验也不好。   

多少最合适的呢？  

不过很难给出具体的值，有的地方会讲，那就是不要超过一个显示屏的垂直高度。比如，在我的电脑上，如果要让一个函数的代码完整地显示在IDE中，那最大代码行数不能超过50。  
   
##### 2.一行代码多长最合适？

这个也没有一个完全的准侧，毕竟语言不同要求也是不同的  

当然有个通用的原则：一行代码最长不能超过IDE显示的宽度。  

太长了就不方便代码的阅读了   

##### 2.善用空行分割单元块  

也就是垂直留白，不太建议我们的代码写下来，代码之前一行空格也没余，通常会根据不同的语义，一个小模块的内容完了，通过空白空格进行分割。   

当然有的地方会讲首行不空格，这也是对的，函授头部的空行是没有任何用的。  

#### 编程技巧  

##### 1.把代码分割成更小的单元块

善于将代码中的模块进行抽象，能够方便我们的阅读  

所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。

##### 2.避免函数参数过多  

函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。  

针对这种情况有两种处理方法  

1、考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。  

2、将函数的参数封装成对象。  

栗子  

```go
type UpdateBookshelfInput struct {
	UserId   primitive.ObjectID
	DeviceId string
	Platform int
	Channel  int
}
```

##### 3.勿用函数参数来控制逻辑 

不要在函数中使用布尔类型的标识参数来控制内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。  

可以拆分成两个函数分别调用  

##### 4.函数设计要职责单一  

对于函数的设计我们也要尽量职责单一，避免设计一个大而全的函数，可以根据不同的功能点，对函数进行拆分。    

举个栗子：我们来校验下我们的额一些用户属性，当然这个校验就省略成判断是否为空了    

```go
func validate(name, phone, email string) error {
	if name == "" {
		return errors.New("name is empty")
	}

	if phone == "" {
		return errors.New("phone is empty")
	}

	if email == "" {
		return errors.New("name is empty")
	}
	return nil
}
```
修改过就是  

```go
func validateName(name string) error {
	if name == "" {
		return errors.New("name is empty")
	}

	return nil
}

func validatePhone( phone string) error {
	if phone == "" {
		return errors.New("phone is empty")
	}

	return nil
}

func validateEmail(name, phone, email string) error {
	if email == "" {
		return errors.New("name is empty")
	}
	return nil
}
```

##### 5.移除过深的嵌套层次

代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的。过深的嵌套，代码除了不好理解外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。  

对于嵌套代码的修改，大概有四个方向可以考虑  

举个栗子：  

这段代码中，有些地方是不太合适的，我们从下面的四个方向来分析  

```go
func sum(sil []int) int {
	count := 0
	if len(sil) == 0 {
		return count
	} else {
		for _, item := range sil {
			if item > 0 {
				count += item
			}
		}
	}
	return count
}
```

1、去掉多余的if或else语句  

修改为  

```go
func sum(sil []int) int {
	count := 0
	if len(sil) >0 {
		for _, item := range sil {
			if item > 0 {
				count += item
			}
		}
	}
	return count
}
```

这样减少了一个 else 判断  

2、使用编程语言提供的continue、break、return关键字，提前退出嵌套  

```go
func sum(sil []int) int {
	count := 0
	if len(sil) > 0 {
		for _, item := range sil {
			if item < 0 {
				continue
			}
			count += item
		}
	}
	return count
}
```

3、调整执行顺序来减少嵌套  

```go
func sum(sil []int) int {
	count := 0
	if len(sil) == 0 {
		return count
	}
	if len(sil) > 0 {
		for _, item := range sil {
			if item < 0 {
				continue
			}
			count += item
		}
	}
	return count
}
```

4、将部分嵌套逻辑封装成函数调用，以此来减少嵌套  

##### 6.学会使用解释性变量  

常用的用解释性变量来提高代码的可读性的情况有下面2种  

1、常量取代魔法数字  

```go
func CalculateCircularArea(radius float64) float64 {

	return 3.1415 * radius * radius
}

// 修改后
const PI = 3.1415
func CalculateCircularArea(radius float64) float64 {

	return PI * radius * radius
}
```

2、使用解释性变量来解释复杂表达式  

```go
if appOnlineTime.Before(userId.Timestamp()) {
	appOnlineTime = userId.Timestamp()
}

// 修改后
isBeforeRegisterTime := appOnlineTime.Before(userId.Timestamp())
if isBeforeRegisterTime {
	appOnlineTime = userId.Timestamp()
}
```




















                        














  


  





  

