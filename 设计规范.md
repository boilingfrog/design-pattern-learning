<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [一些设计规范摘录](#%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [滥用全局变量和全局方法](#%E6%BB%A5%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95)
  - [接口](#%E6%8E%A5%E5%8F%A3)
  - [是否推荐使用继承](#%E6%98%AF%E5%90%A6%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF)
  - [贫血模型的MVC架构](#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84mvc%E6%9E%B6%E6%9E%84)
  - [基于充血模型的DDD开发模式](#%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84ddd%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F)
  - [单一职责原则（SRP）](#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
    - [理解单一职责原则（SRP）](#%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp)
    - [如何判断类的职责是否足够单一](#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E5%8D%95%E4%B8%80)
    - [类的职责是否设计得越单一越好](#%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%AE%BE%E8%AE%A1%E5%BE%97%E8%B6%8A%E5%8D%95%E4%B8%80%E8%B6%8A%E5%A5%BD)
  - [开闭原则](#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99)
    - [如何理解“对扩展开放、修改关闭”](#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD)
    - [如何做到“对扩展开放、修改关闭”？](#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD)
  - [里式替换原则（LSP）](#%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp)
    - [违背LSP的场景](#%E8%BF%9D%E8%83%8Clsp%E7%9A%84%E5%9C%BA%E6%99%AF)
  - [接口隔离原则](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99)
    - [把“接口”理解为一组API接口集合](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BA%E4%B8%80%E7%BB%84api%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88)
    - [把“接口”理解为单个API接口或函数](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BA%E5%8D%95%E4%B8%AAapi%E6%8E%A5%E5%8F%A3%E6%88%96%E5%87%BD%E6%95%B0)
    - [把“接口”理解为OOP中的接口概念](#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%E4%B8%BAoop%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5)
    - [接口隔离原则与单一职责原则的区别](#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E4%B8%8E%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [依赖反转原则](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99)
    - [控制反转（IOC）](#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc)
    - [依赖注入（DI）](#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di)
    - [依赖反转原则（DIP）](#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99dip)
  - [如何理解“KISS原则”](#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3kiss%E5%8E%9F%E5%88%99)
    - [如何写出满足KISS原则的代码？](#%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%BB%A1%E8%B6%B3kiss%E5%8E%9F%E5%88%99%E7%9A%84%E4%BB%A3%E7%A0%81)
  - [YAGNI原则](#yagni%E5%8E%9F%E5%88%99)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 一些设计规范摘录

### 前言

设计模式学习的一些笔记  

### 滥用全局变量和全局方法

**全局常量的使用**  

全局常量我们尽量不要统一放在同一个地方  

- 1、因为随着变量的增多，会影响代码的可维护性 

参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个文件，会造成这个文件很大，同时也增加了代码冲突的概率。  

- 会增加代码的编译时间  

每次修改这个文件，所有这个文件，所有依赖这个文件的代码就会编译，增加编译时间  

如何使用最优化  

我们可以把不同类型的群居变量放到把不同的文件中，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计Constants常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig类用到了Redis配置相关的常量，那我们就直接将这些常量定义在RedisConfig中，这样也提高了类设计的内聚性和代码的复用性。  

**Utils类**

Utils 能解决代码复用的问题，虽然只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。   

当然，我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，不要设计一个过于大而全的Utils类。  
   
### 接口

接口设计的原则：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。  

什么时候需要封装接口？  

- 1、如果某个功能只有一种实现那么我们就没必要定义接口了。  

- 2、越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。  

### 是否推荐使用继承

继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性  

我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，来替换继承。   

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。  

### 贫血模型的MVC架构

来看下什么是贫血模式  

MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。  

我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然不同的团队有不同的命名，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。  

```
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    return userVo;
  }
}

public class UserVo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}
``` 

其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。  

UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。  

### 基于充血模型的DDD开发模式  

什么是充血模式？  

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。  

基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。它跟基于贫血模型的传统开发模式的区别主要在Service层。  

在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。  

### 单一职责原则（SRP）

#### 理解单一职责原则（SRP）

单一职责原则的英文是Single Responsibility Principle，缩写为SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。  

原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念的理解  

一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。  

另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。  

接下我们从类的角度进行分析  

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。  

举个栗子  

比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。  

#### 如何判断类的职责是否足够单一

评级一个类是否单一，没有一个明确的标准可以量化的，实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。   

我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构  

下面的几个原则可以作为直观的判断类是否单一  

1、类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；  

2、类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；  

3、私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；  

4、比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；  

5、类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来  

一般一个类的代码行数最好不能超过200行，函数个数及属性个数都最好不要超过10个。  

#### 类的职责是否设计得越单一越好

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。  

### 开闭原则

扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。  

#### 如何理解“对扩展开放、修改关闭”

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。   

不过添加新功能不修改任何模板，类，方法，这个肯定是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。  

#### 如何做到“对扩展开放、修改关闭”？  

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。  

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）  

也就是我们首先要去学习下这23种设计模式   

### 里式替换原则（LSP）

什么是里式替换原则：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。  

从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。  

#### 违背LSP的场景

1、子类违背父类声明要实现的功能 

2、子类违背父类对输入、输出、异常的约定  

3、子类违背父类注释中所罗列的任何特殊说明  

父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。  

### 接口隔离原则

什么意思呢：Robert Martin在SOLID原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。  

关于接口的理解：  

- 一组API接口集合

- 单个API接口或函数

- OOP中的接口概念

#### 把“接口”理解为一组API接口集合

如果理解为一组 api 接口的话，在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。  

如果 API 接口集合中放置了我们用到的接口，那么我们可以认为不符合接口隔离原则。  

#### 把“接口”理解为单个API接口或函数

这里就不是单个API接口或函数统称为函数了。  

那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。  

#### 把“接口”理解为OOP中的接口概念

接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。  

#### 接口隔离原则与单一职责原则的区别

仔细想想和单一职责原则有点类似，不过还是有差别的。  

- 单一职责原则针对的是模块、类、接口的设计。  

- 接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。   

它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。  

### 依赖反转原则

在学习依赖反转原则之前我们先来了解几个概念 控制反转、依赖反转、依赖注入  

#### 控制反转（IOC）

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。  

#### 依赖注入（DI）

依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。  

我们用一句话表示就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。  

#### 依赖反转原则（DIP）

依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP。  

什么是依赖反转原则：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。  

所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。不过平时在业务代码的开发中，高层模块依赖底层模块是没有任何问题的。这里我们讲的这个原则主要是针对框架层面的开发设计和开发的。  
 
### 如何理解“KISS原则”

KISS原则是英语 Keep It Simple, Stupid 的首字母缩略字，是一种归纳过的经验原则。KISS 原则是指在设计当中应当注重简约的原则。总结工程专业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而不掺入非必要的复杂性，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，尽量回避免不必要的复杂性

代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。  

#### 如何写出满足KISS原则的代码？

- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。  

- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。  

- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。  

就是尽量做到把很难的东西做到简单化    

### YAGNI原则

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。  

比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。  

KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。  



  


  





  

