<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [一些设计规范摘录](#%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [滥用全局变量和全局方法](#%E6%BB%A5%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95)
  - [接口](#%E6%8E%A5%E5%8F%A3)
  - [是否推荐使用继承](#%E6%98%AF%E5%90%A6%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF)
  - [贫血模型的MVC架构](#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84mvc%E6%9E%B6%E6%9E%84)
  - [基于充血模型的DDD开发模式](#%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84ddd%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 一些设计规范摘录

### 前言

设计模式学习的一些笔记  

### 滥用全局变量和全局方法

**全局常量的使用**  

全局常量我们尽量不要统一放在同一个地方  

- 1、因为随着变量的增多，会影响代码的可维护性 

参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个文件，会造成这个文件很大，同时也增加了代码冲突的概率。  

- 会增加代码的编译时间  

每次修改这个文件，所有这个文件，所有依赖这个文件的代码就会编译，增加编译时间  

如何使用最优化  

我们可以把不同类型的群居变量放到把不同的文件中，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计Constants常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig类用到了Redis配置相关的常量，那我们就直接将这些常量定义在RedisConfig中，这样也提高了类设计的内聚性和代码的复用性。  

**Utils类**

Utils 能解决代码复用的问题，虽然只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。   

当然，我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，不要设计一个过于大而全的Utils类。  
   
### 接口

接口设计的原则：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。  

什么时候需要封装接口？  

- 1、如果某个功能只有一种实现那么我们就没必要定义接口了。  

- 2、越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。  

### 是否推荐使用继承

继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性  

我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，来替换继承。   

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。  

### 贫血模型的MVC架构

来看下什么是贫血模式  

MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。  

我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然不同的团队有不同的命名，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。  

```
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    return userVo;
  }
}

public class UserVo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}
``` 

其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。  

UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。  

### 基于充血模型的DDD开发模式  

什么是充血模式？  

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。  

基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。它跟基于贫血模型的传统开发模式的区别主要在Service层。  

在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。  




  

